/*
 * Copyright 2023-2024 NXP
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

/***********************************************************************************************************************
 * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
 * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
 **********************************************************************************************************************/
/*
 * How to set up clock using clock driver functions:
 *
 * 1. Setup clock sources.
 *
 * 2. Set up all selectors to provide selected clocks.
 *
 * 3. Set up all dividers.
 */

#include "fsl_clock.h"
#include "clock_config.h"
#include "fsl_power.h"

/*******************************************************************************
 * Definitions
 ******************************************************************************/

/*******************************************************************************
 * Variables
 ******************************************************************************/
/* System clock frequency. */
extern uint32_t SystemCoreClock;

/*PLL 528MHZ*/
const clock_main_pll_config_t g_mainPllConfig_BOARD_BootClockRUN = {
    .main_pll_src  = kCLOCK_MainPllOscClk, /* OSC clock */
    .numerator     = 0,                    /* Numerator of the SYSPLL0 fractional loop divider is 0 */
    .denominator   = 1,                    /* Denominator of the SYSPLL0 fractional loop divider is 1 */
    .main_pll_mult = kCLOCK_MainPllMult22  /* Divide by 22 */
};

const clock_audio_pll_config_t g_audioPllConfig_BOARD_BootClockRUN = {
    .audio_pll_src  = kCLOCK_AudioPllOscClk,   /* OSC clock */
    .numerator      = 5040,                    /* Numerator of the Audio PLL fractional loop divider is 0 */
    .denominator    = 27000,                   /* Denominator of the Audio PLL fractional loop divider is 1 */
    .audio_pll_mult = kCLOCK_AudioPllMult22,   /* Divide by 22 */
    .enableVcoOut   = true
};
/*******************************************************************************
 ************************ BOARD_InitBootClocks function ************************
 ******************************************************************************/
/*FUNCTION**********************************************************************
 *
 * Function Name : BOARD_XspiClockSafeConfig
 * Description   : XSPI clock source safe configuration weak function.
 *                 Called before clock source(Such as PLL, Main clock) configuration.
 * Note          : Users need override this function to change XSPI clock source to stable source when executing
 *                 code on XSPI memory(XIP). If XIP, the function should runs in RAM and move the XSPI clock
 *source to an stable clock to avoid instruction/data fetch issue during clock updating.
 *END**************************************************************************/
__attribute__((weak)) void BOARD_XspiClockSafeConfig(void)
{
}

__attribute__((weak)) void BOARD_SetXspiClock(XSPI_Type *base, uint32_t src, uint32_t divider)
{
}

void BOARD_InitBootClocks(void)
{
    BOARD_BootClockRUN();
}

/*******************************************************************************
 ********************** Configuration BOARD_BootClockRUN ***********************
 ******************************************************************************/

/*******************************************************************************
 * Variables for BOARD_BootClockRUN configuration
 ******************************************************************************/

/*******************************************************************************
 * Code for BOARD_BootClockRUN configuration
 ******************************************************************************/
void BOARD_BootClockRUN(void)
{
    const clock_fro_config_t froAutotrimCfg = {
        .targetFreq   = 300000000U,
        .range        = 50U,
        .trim1DelayUs = 15U,
        .trim2DelayUs = 150U,
        .refDiv       = 1U,
        .enableInt    = 0U,
        .coarseTrimEn = true,
    };

    POWER_DisablePD(kPDRUNCFG_PD_LPOSC);

    /* Power up OSC */
    POWER_DisablePD(kPDRUNCFG_PD_SYSXTAL);
    CLOCK_EnableSysOscClk(true, true, BOARD_SYSOSC_SETTLING_US); /* Enable system OSC */
    CLOCK_SetXtalFreq(BOARD_XTAL_SYS_CLK_HZ);                    /* Sets external XTAL OSC freq */

    POWER_DisablePD(kPDRUNCFG_PD_FRO1); /* Make sure FRO1 is enabled. */

    /* Switch to FRO1 for safe configure. */
    CLOCK_AttachClk(kFRO1_DIV1_to_COMPUTE_BASE);
    CLOCK_AttachClk(kCOMPUTE_BASE_to_COMPUTE_MAIN); 
    CLOCK_SetClkDiv(kCLOCK_DivCmptMainClk, 1U);
    CLOCK_AttachClk(kFRO1_DIV1_to_RAM);
    CLOCK_SetClkDiv(kCLOCK_DivComputeRamClk, 1U);
    CLOCK_AttachClk(kFRO1_DIV1_to_COMMON_BASE);
    CLOCK_AttachClk(kCOMMON_BASE_to_COMMON_VDDN);
    CLOCK_SetClkDiv(kCLOCK_DivCommonVddnClk, 1U);

    BOARD_XspiClockSafeConfig(); /*Change to common_base clock(Sourced by FRO1). */

    /* Ungate all FRO clock. */
    POWER_DisablePD(kPDRUNCFG_GATE_FRO0);
    CLOCK_EnableFroClkFreqCloseLoop(FRO0, &froAutotrimCfg, kCLOCK_FroAllOutEn); /* Use close loop mode. */
    CLOCK_EnableFro0ClkForDomain(kCLOCK_AllDomainEnable); /* Enable FRO0 MAX clock for all domains. */

    CLOCK_InitMainPll(&g_mainPllConfig_BOARD_BootClockRUN);
    CLOCK_InitMainPfd(kCLOCK_Pfd0, 20U); /* 475MHz */
    CLOCK_InitMainPfd(kCLOCK_Pfd1, 24U); /* 396MHz */
    CLOCK_InitMainPfd(kCLOCK_Pfd2, 18U); /* 528MHz */
    CLOCK_InitMainPfd(kCLOCK_Pfd3, 19U); /* Main PLL kCLOCK_Pfd3 (528 * 18 / 19) = 500MHz -need 2 div  -> 250MHz*/

    CLOCK_EnableMainPllPfdClkForDomain(kCLOCK_Pfd0, kCLOCK_AllDomainEnable);
    CLOCK_EnableMainPllPfdClkForDomain(kCLOCK_Pfd1, kCLOCK_AllDomainEnable);
    CLOCK_EnableMainPllPfdClkForDomain(kCLOCK_Pfd2, kCLOCK_AllDomainEnable);
    CLOCK_EnableMainPllPfdClkForDomain(kCLOCK_Pfd3, kCLOCK_AllDomainEnable);

    CLOCK_SetClkDiv(kCLOCK_DivCmptMainClk, 2U);
    CLOCK_AttachClk(kMAIN_PLL_PFD0_to_COMPUTE_MAIN); /* Switch to PLL 230MHZ */

    CLOCK_SetClkDiv(kCLOCK_DivMediaMainClk, 2U);
    CLOCK_AttachClk(kMAIN_PLL_PFD0_to_MEDIA_MAIN); /* Switch to PLL 230MHZ */

    CLOCK_SetClkDiv(kCLOCK_DivMediaVddnClk, 2U);
    CLOCK_AttachClk(kMAIN_PLL_PFD0_to_MEDIA_VDDN); /* Switch to PLL 230MHZ */

    CLOCK_SetClkDiv(kCLOCK_DivComputeRamClk, 2U);
    CLOCK_AttachClk(kMAIN_PLL_PFD0_to_RAM); /* Switch to PLL 230MHZ */

    CLOCK_SetClkDiv(kCLOCK_DivCommonVddnClk, 2U);
    CLOCK_AttachClk(kMAIN_PLL_PFD3_to_COMMON_VDDN); /* Switch to 250MHZ */

    /* Configure Audio PLL clock source. */
    CLOCK_InitAudioPll(&g_audioPllConfig_BOARD_BootClockRUN); /* 532.48MHZ */
    CLOCK_InitAudioPfd(kCLOCK_Pfd1, 24U);  /* 399.36MHz */
    CLOCK_InitAudioPfd(kCLOCK_Pfd3, 26U);  /* Enable Audio PLL PFD3 clock to 368.64MHZ */
    CLOCK_EnableAudioPllPfdClkForDomain(kCLOCK_Pfd1, kCLOCK_AllDomainEnable);
    CLOCK_EnableAudioPllPfdClkForDomain(kCLOCK_Pfd3, kCLOCK_AllDomainEnable);

    /* Call function BOARD_SetXspiClock() to set user configured clock source/divider for XSPI. */
    BOARD_SetXspiClock(XSPI0, 3U, 1U); /* Main PLL PDF1 DIV1. */

    SystemCoreClock = BOARD_BOOTCLOCKRUN_CORE_CLOCK;
}
